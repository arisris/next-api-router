var p=class extends Error{};function h(u){let{key:l,timeout:x,onError:d}=Object.assign({key:"any",timeout:1e4,onError:(e,r,t)=>{if(e instanceof p)t.status(500).send("<h3>Timeout Error</h3>");else throw e}},u),R=[],y=async(e,r)=>{try{let t=e.query[l],n=e.url.split("/").filter(o=>t&&Array.isArray(t)?!t.some(s=>s===o):!t.includes(o)).join("/");delete e.query[l];let a=o=>RegExp(`^${(n+o).replace(/(\/?)\*/g,"($1.*)?").replace(/\/$/,"").replace(/:(\w+)(\?)?(\.)?/g,"$2(?<$1>[^/]+)$2$3").replace(/\.(?=[\w(])/,"\\.").replace(/\)\.\?\(([^\[]+)\[\^/g,"?)\\.?($1(?<=\\.)[^\\.")}/*$`),c,m,i;x&&(i=setTimeout(()=>{clearTimeout(i),d(new p("Request timeout"),e,r)},x));for(let[o,s,N]of R)if((o===e.method||o==="ALL")&&(c=a(s).exec(e.url))){e.params=c.groups;for(let f of N)if(m=await f(e,r),r.writableFinished){i&&clearTimeout(i);break}}}catch(t){return d(t,e,r)}},A=(e,r,t)=>r==="handle"?e.handle.bind(e):(n,...a)=>R.push([r.toUpperCase(),n,a])&&t;return new Proxy({handle:y},{get:A})}export{p as TimeoutError,h as default};
//# sourceMappingURL=index.js.map
